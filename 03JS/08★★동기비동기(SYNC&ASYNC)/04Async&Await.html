<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .box {
            width: 1280px;
            height: 800px;
            border: 1px solid;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
        }

        .box>.main-thread {
            width: 300px;
            border: 1px solid;
            height: 100%;
        }

        .box>.sub1-thread {
            width: 300px;
            border: 1px solid;
            height: 100%;
        }

        .box>.sub2-thread {
            width: 300px;
            border: 1px solid;
            height: 100%;
        }
    </style>
</head>

<body>
    <div class="box">
        <div class="main-thread"></div>
        <div class="sub1-thread"></div>
        <div class="sub2-thread"></div>
    </div>

    <script>
        const mainThreadEl = document.querySelector('.main-thread');
        const sub1ThreadEl = document.querySelector('.sub1-thread');
        const sub2ThreadEl = document.querySelector('.sub2-thread');


        //resolve(성공) == 성공시 전달할 값  reject(실패) == 오류 발생 시 전달할 값
        //Promise 비동기 처리 객체 확인해보기
        // new Promise((resolve,reject)=>{
        //     //요청작업
        //     setTimeout(()=>{    // 서버로 내용을 요청하는 코드로 바뀔 것임
        //         const success =true;
        //         if(success){    //비동기 작업이 성공한다면
        //             resolve("요청 성공 : 서버로부터 데이터 수신완료!"); //정상적으로 동작 시, 따로 응답은 X 
        //         }else{
        //             reject("요청 실패 : 서버오류(500)")
        //         }
        //     },3000);
        // })
        // .then((response)=>{console.log(response);})   //정상처리(resolve)시 후속 처리
        // .catch((error)=>{console.log(error);})  //오류발생(reject)시 후속 처리


        //메인스레드 생성(왼쪽 블럭 번복처리)
        let cnt = 0;
        setInterval(()=>{
            mainThreadEl.innerHTML += `MAIN THREAD...${++cnt}<br/>`;
        },1000)


        // 비동기 처리 프로세스(분할된 스레드) 간의 처리순서를 정할 때 사용되는 것 == async, await
        // 비동기 기본 함수 
        function sub_process_executor(val){
            return new Promise((resolve,reject)=>{ //resolve,reject => Promise 내의 기능을 사용해서 성공/실패 시 반환 값 지정 가능

                setTimeout(()=>{
                    resolve(val);   //resolve에서 전달받은 val값을 return하도록(무조건 성공이라 생각하고)
                },3000)
            });   
        }


        // Async / Await 사용없이 비동기 처리 진행 == 비동기 처리 간의 순서가 없는 것
        // 콘솔 창에 동시에 뜸
        // sub_process_executor(11)     //promise를 반환함
        // .then((response)=>{console.log('sub1..',response);sub1ThreadEl.innerHTML=`sub1...${response}`})
                //resolve(val)이 response에 삽입됨            //화면에 보여줌
        //         
        // .catch((error)=>{})

        // sub_process_executor(22)
        // .then((response)=>{console.log('sub2..',response;sub2ThreadEl.innerHTML=`sub2...${response}`)})
        // .catch((error)=>{})


        // Async/ Await 사용해서 비동기 처리 간의 순서 생성
        async function sub_process_order() {
            await sub_process_executor(22)
                 .then((response)=>{console.log('sub2..',response);sub2ThreadEl.innerHTML=`sub2...${response}`})
                 .catch((error)=>{})

            await sub_process_executor(11)
                .then((response)=>{console.log('sub1..',response);sub1ThreadEl.innerHTML=`sub1...${response}`})
                .catch((error)=>{})

        }
        sub_process_order();

    </script>
</body>

</html>