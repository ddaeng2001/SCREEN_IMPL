<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    




    <script>
        // 배열 : 여러 자료Type을 저장하기 위한 자료구조
        // let arr=['str1',"str2",`str3`,null,true,false,undefined,{name:"홍길동",age:15}];
        //         //스트링, 오브젝트,
        //         //다른 자료형도 한 배열 안에 넣을 수 있음 (cf)java는 불가능)
                
        // console.log(arr);
        // console.log(arr[0]);
        // console.log(arr[1]);
        // console.log(arr[2]);
        // console.log(arr[3]);
        // console.log(arr[4]);
        // console.log(arr[5]);
        // console.log(arr[6]);
        // console.log(arr[7]);
        //
        // arr[8] = 100;
        // //데이터를 추가할수록 길이(length)가 늘어남 == 유연
        // console.log(arr);
        // arr[10] = "HELLO WORLD";
        // console.log(arr);
        // //9번 인덱스에 데이터를 넣지 않고 뛰어넘어도 비어놓고 10번에 데이터를 담음
        // //9번의 자료형 == undefined
        // console.log(typeof arr[9], typeof arr[10])



        // //---------------------------------------------------
        // //배열함수 : push, pop --> 스택 구조에서 사용 가능
        // //---------------------------------------------------

        // arr.push('aaa');
        // arr.push('bbb');
        // arr.push('ccc');
        // console.log(arr);
        // arr.pop();
        // arr.pop();
        // console.log(arr);



        //---------------------------------------------------
        //배열함수 : forEach --> 배열 요소에 하나하나에 접근해서 확인할 때
                    //반복문과 비슷함
        //---------------------------------------------------

        // console.log("------------------------");
        // arr.forEach((item)=>{console.log('item',item);});
            //콜백함수: 로직<()=>{}>을 전달받는 함수    
                   // (각각의 요소의 이름)=>{}




        // //------------------------------------------------------
        // // 정렬 : arr.sort((a,b)=>{return a-b}) 
        // //: 복사본이 아닌 원본을 수정하는 것 (==java의 labmda와 비슷함)
        // //------------------------------------------------------
        // let arr2=[10,55,11,24,5,44,1,22];
        // // //오름차순 정렬
        // // arr2.sort((a,b)=>{return a-b;});
        // // console.log(arr2);

        // //내림차순 정렬
        // // arr2.sort((a,b)=>{return b-a;});
        // // console.log(arr2);

        // //약식
        // arr2.sort((a,b)=>b-a);
        //         //코드라인이 한 라인에서 끝난다면(==단순한 내림/오름차순이라면) return 예약어는 생략가능
        // console.log(arr2);



        // //------------------------------------------------------
        // // 필터: 특정 조건을 만족하는 데이터만 꺼내오는 것(원하는 값만)
        // //------------------------------------------------------

        // let arr3=[11,'str1',22,"str2",33,`str3`,10.5,null,true,false,undefined,101,{name:"홍길동",age:15}];

        // //숫자만 필터링
        // let result = arr3.filter((item)=>{return typeof item=="number"});
        // //원래 배열(let arr3)과는 다르게 새로운 배열(let result)을 만들어서 필터링함
        // console.log(result);

        // //글자만 필터링
        // let result2 = arr3.filter((item)=>{return typeof item=="string"});
        //                                    //return 생략가능
        // console.log(result2);




        // //------------------------------------------------------
        // // 누산(누적한 값) : arr.reduce (()=>{}, 누산변수 초기값)
        // //------------------------------------------------------
        
        // //필터링 후 누산
        // const sum = arr3.filter((item)=>{return typeof item=="number"})     //숫자값만 필터
        //             //arr3과는 별개로 숫자만 필터링 된 새로운 배열

        //                 .reduce((sum,item)=>{return sum+item},0)            //누적합 구하기
        //                         //(누적하기 위한 변수, 필터링 된 변수)
        //                //-->체인형태로 함수를 붙여서 사용가능

        // console.log(sum);



        //----------------------------------
        // 배열object 처리 [{},{},{},{}...]
        //----------------------------------
        // let arr_5 = [
        //     {pid:"1",pname:"모니터",price:100,amount:50},
        //     {pid:"2",pname:"노트북",price:200,amount:15},
        //     {pid:"3",pname:"냉장고",price:250,amount:30},
        //     {pid:"4",pname:"데스크탑",price:70,amount:19},
        //     {pid:"5",pname:"가습기",price:10,amount:200},
        // ];
        // // console.log(arr_5);
        // // arr_5.forEach((item)=>{console.log(item);})

        // // 약식
        // // arr_5.forEach(item=>console.log(item))
        //                 // ()내에 한 개만 존재하면 생략가능

        // // index - 배열의 순서번호도 확인 가능
        // // arr_5.forEach((item,index)=>{console.log(index,item);})
                            
        // //해당 위치에 있는 object 값 확인가능
        // // arr_5.forEach((item,index)=>{console.log(item["price"]);})
        //                                                 //key 값

        // // 각 item의 가격이 100만원이상인 object만 필터링
        // // const filter_01 = arr_5.filter(item=>item["price"]>=100) //약식
        // // const filter_01 = arr_5.filter(item=>item.price>=100) //약식

        // //위에 둘 다 가능!! 동일한 결과값 다른 코드
        // // console.log(filter_01);



        // //QUESTION
        // // 각 아이템 수량이 30개 이하인 object만 필터링
        // const filter_02 = arr_5.filter(item=>item["amount"]<=30)
        // console.log(filter_02);

        // // 각 아이템 가격이 100만원 이상인 item의 가격 총합(누적)을 구하세요
        // const sum_01 = arr_5.filter(item=>item.price>=100)
        //                     .reduce((sum,item)=>{return sum+(item.price*item.amount);},0)
        //                             //(누적값, 각 요소들)
        //                             // item = 각각의 요소들을 꺼내기 위한 것
        // console.log(sum_01);



        // mdn 배열함수
        // (多쓰임)재구성 배열.map(()=>{})
        // 현재 가지고 있는 배열에 속성을 추가해서 새로운 배열 object를 생성함
        // 프론트 엔드 react에서 많이 사용됨

        // let arr_6 = [
        //     {pid:"1",pname:"모니터",price:100,amount:50},
        //     {pid:"2",pname:"노트북",price:200,amount:15},
        //     {pid:"3",pname:"냉장고",price:250,amount:30},
        //     {pid:"4",pname:"데스크탑",price:70,amount:19},
        //     {pid:"5",pname:"가습기",price:10,amount:200},
        // ];

        // let maped_01 = arr_6.map((item)=>{          //arr_6과 동일하지만 새롭게 생성한 것
            
        //     item={...item,"total_price":item.price*item.amount}; 
        //         //...<스프레드 연산자> : 기존의 item에 있는 내용을 그대로 옮겨오면서 새로운 요소를 추가할 때 사용됨
        //         //item의 각 요소들을 가져와서 item에 담음
        //         //"total_price":item.price*item.amount == 새로운 요소를 추가한 것
        //         //"key":value(for 새로운 요소 추가)
        //     return item;
        //     console.log("!",item);
        
        // })
        // console.log(maped_01);



        // 수량이 30이상인 요소만 필터링해서/ price가 낮은값우선 오름차순 / price*amount 항목 추가
        // const total = arr_6.filter((item)=>{return item.amount>=30})
        //                  .sort((a,b)=>{return a.price-b.price;})
        //                  .map((item)=>{
        //                     item={...item,"pricenamount":item.price*item.amount};
        //                     return item;
        //                  })
        // console.log(total);

    

        //----------------------------------
        //  문제
        //----------------------------------
        let employees = [
            { id: 1, name: "김철수", age: 35, department: "개발", salary: 6000, years: 10 },
            { id: 2, name: "이영희", age: 28, department: "디자인", salary: 5000, years: 5 },
            { id: 3, name: "박지성", age: 40, department: "마케팅", salary: 7000, years: 15 },
            { id: 4, name: "손흥민", age: 30, department: "개발", salary: 6500, years: 7 },
            { id: 5, name: "정우성", age: 45, department: "경영", salary: 9000, years: 20 },
            { id: 6, name: "한지민", age: 29, department: "디자인", salary: 5200, years: 6 },
            { id: 7, name: "강호동", age: 50, department: "경영", salary: 8500, years: 25 },
            { id: 8, name: "유재석", age: 42, department: "마케팅", salary: 7500, years: 18 },
            { id: 9, name: "송중기", age: 32, department: "개발", salary: 6200, years: 8 },
            { id: 10, name: "수지", age: 26, department: "디자인", salary: 4800, years: 3 }
        ];

    //연봉이(salary) 6000이상이면서 근속연수(years)가 7년이상인(item.salary>=6000 && item.years>=7) 
    // 직원만 필터링해서 배열로 저장 확인
    // const q1 = employees.filter((item)=>{return item.salary>=6000 && item.years>=7})
    // console.log(q1)

    // //모든 직원의 연봉(salary) 기준으로 내림차순 정렬한 배열 새로 만들기
    // const q2 = employees.sort((a,b)=>{return b.salary-a.salary})
    // console.log(q2)

    // //모든 직원의 연봉(salary) 에 근속연수*100 만큼의 보너스를 추가하여 total_salary필드를 추가한 배열을 반환
    // const q3 = employees.map((item)=>{
    //                         item={...item,"total_salary" : item.salary+item.years*100}
    //                         return item;})
    // console.log(q3);

    //department(부서) 별로 직원들의 연봉총합을 구하세요
    // const dev = employees.filter((item)=>{return item.department == "개발"})
    //                     .reduce((sum,item)=>{return sum+item.salary},0)
    // console.log(dev)

    // const design = employees.filter((item)=>{return item.department == "디자인"})
    //                     .reduce((sum,item)=>{return sum+item.salary},0)
    // console.log(design)

    // const marketing = employees.filter((item)=>{return item.department == "마케팅"})
    //                     .reduce((sum,item)=>{return sum+item.salary},0)
    // console.log(marketing)

    // const employ = employees.filter((item)=>{return item.department == "경영"})
    //                     .reduce((sum,item)=>{return sum+item.salary},0)
    // console.log(employ)

    // console.log(employees)
    // const result4 = employees.reduce((sum,item)=> {
    //     sum[item.department]=sum[item.department]==undefined?item.salary:sum[item.department]
    //     console.log(sum);
    //     return sum;
    // },{});
    // console.log(result4);


    // 연봉(salary)가 가장높은 직원을 찾아 객체하나만 반환(mdn문서에서 find를 찾아보세요 - !)
    // const top_s = employees.sort((a,b)=>{return b.salary-a.salary})[0];
    // console.log(top_s);

    //최대값 구하기
    const max_items2 = employees.find((item)=>{return item.salary==max_item.age;});
    console.log(max_items2);


    </script>
</body>
</html>